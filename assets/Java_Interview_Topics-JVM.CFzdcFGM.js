import{_ as b}from"./ValaxyMain.vue_vue_type_style_index_0_lang.Cc24E21L.js";import{f,a as v,u as z}from"./chunks/vue-router.7WTmP7zY.js";import{N as y,$ as u,Q as o,R as l,V as j,W as i,u as S,O as L,D as K}from"./framework.BU8aqy2L.js";import"./app.BB9ub2XN.js";import"./chunks/dayjs.WH26RRM8.js";import"./chunks/vue-i18n.BwO6G1QQ.js";import"./chunks/nprogress.t5q147rN.js";import"./chunks/pinia.Dovo_Y_t.js";import"./chunks/@vueuse/motion.C0KIn7Jt.js";import"./YunComment.vue_vue_type_style_index_0_lang.Db3ggHvU.js";import"./index.C5okkQwF.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang.CPLWUEU4.js";import"./post.CUSDhX7O.js";const M=f("/posts/Java_Interview_Topics-JVM",async r=>JSON.parse('{"title":"Java面试专题-虚拟机篇","description":"","frontmatter":{"cover":"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/Knight.png","title":"Java面试专题-虚拟机篇","date":"2023-4-16 14:52:05","categories":"Java","tags":["JVM 内存结构","JVM 内存参数","JVM 垃圾回收","内存溢出","类加载","引用","finalize"],"top":120,"outline":"deep","excerpt_type":"html","end":false},"headers":[{"level":2,"title":"1. JVM 内存结构","slug":"_1-jvm-内存结构","link":"#_1-jvm-内存结构","children":[]},{"level":2,"title":"2. JVM 内存参数","slug":"_2-jvm-内存参数","link":"#_2-jvm-内存参数","children":[]},{"level":2,"title":"3. JVM 垃圾回收","slug":"_3-jvm-垃圾回收","link":"#_3-jvm-垃圾回收","children":[]},{"level":2,"title":"4. 内存溢出","slug":"_4-内存溢出","link":"#_4-内存溢出","children":[]},{"level":2,"title":"5. 类加载","slug":"_5-类加载","link":"#_5-类加载","children":[]},{"level":2,"title":"6. 四种引用","slug":"_6-四种引用","link":"#_6-四种引用","children":[]},{"level":2,"title":"7. finalize","slug":"_7-finalize","link":"#_7-finalize","children":[]}],"relativePath":"pages/posts/Java_Interview_Topics-JVM.md","lastUpdated":null}'),{lazy:(r,g)=>r.name===g.name}),A={__name:"Java_Interview_Topics-JVM",setup(r,{expose:g}){var a;const{data:e}=M(),p=z(),m=v(),s=Object.assign(m.meta.frontmatter||{},((a=e.value)==null?void 0:a.frontmatter)||{});return m.meta.frontmatter=s,p.currentRoute.value.data=e.value,K("valaxy:frontmatter",s),globalThis.$frontmatter=s,g({frontmatter:{cover:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/Knight.png",title:"Java面试专题-虚拟机篇",date:"2023-4-16 14:52:05",categories:"Java",tags:["JVM 内存结构","JVM 内存参数","JVM 垃圾回收","内存溢出","类加载","引用","finalize"],top:120,outline:"deep",excerpt_type:"html",end:!1}}),(t,n)=>{const d=b;return L(),y(d,{frontmatter:S(s)},{"main-content-md":u(()=>[n[0]||(n[0]=l("p",null,[i("参考视频："),l("a",{href:"https://www.bilibili.com/video/BV15b4y117RJ",target:"_blank",rel:"noreferrer"},"满神Java面试专题")],-1)),n[1]||(n[1]=l("p",null,"笔记的整体结构依据视频编写，并随着学习的深入补充了很多知识",-1)),j(" more "),n[2]||(n[2]=l("h2",{id:"_1-jvm-内存结构",tabindex:"-1"},[i("1. JVM 内存结构 "),l("a",{class:"header-anchor",href:"#_1-jvm-内存结构","aria-label":'Permalink to "1. JVM 内存结构"'},"​")],-1)),n[3]||(n[3]=l("p",null,[l("strong",null,"要求")],-1)),n[4]||(n[4]=l("ul",null,[l("li",null,"掌握 JVM 内存结构划分"),l("li",null,"尤其要知道方法区、永久代、元空间的关系")],-1)),n[5]||(n[5]=l("p",null,[l("strong",null,"结合一段 java 代码的执行理解内存划分")],-1)),n[6]||(n[6]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831165728217.png",alt:"image-20210831165728217",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[7]||(n[7]=l("ul",null,[l("li",null,"执行 javac 命令编译源代码为字节码"),l("li",null,[i("执行 java 命令 "),l("ol",null,[l("li",null,[i("创建 JVM，调用类加载子系统加载 class，将类的信息存入"),l("strong",null,"方法区")]),l("li",null,[i("创建 main 线程，使用的内存区域是 "),l("strong",null,"JVM 虚拟机栈"),i("，开始执行 main 方法代码")]),l("li",null,[i("如果遇到了未见过的类，会继续触发类加载过程，同样会存入"),l("strong",null,"方法区")]),l("li",null,[i("需要创建对象，会使用"),l("strong",null,"堆"),i("内存来存储对象")]),l("li",null,[i("不再使用的对象，会由"),l("strong",null,"垃圾回收器"),i("在内存不足时回收其内存")]),l("li",null,[i("调用方法时，方法内的局部变量、方法参数所使用的是 "),l("strong",null,"JVM 虚拟机栈"),i("中的栈帧内存")]),l("li",null,[i("调用方法时，先要到"),l("strong",null,"方法区"),i("获得到该方法的字节码指令，由"),l("strong",null,"解释器"),i("将字节码指令解释为机器码执行")]),l("li",null,[i("调用方法时，会将要执行的指令行号读到"),l("strong",null,"程序计数器"),i("，这样当发生了线程切换，恢复时就可以从中断的位置继续")]),l("li",null,[i("对于非 java 实现的方法调用，使用内存称为"),l("strong",null,"本地方法栈"),i("（见说明）")]),l("li",null,[i("对于热点方法调用，或者频繁的循环代码，由 "),l("strong",null,"JIT 即时编译器"),i("将这些代码编译成机器码缓存，提高执行性能")])])])],-1)),n[8]||(n[8]=l("p",null,"说明",-1)),n[9]||(n[9]=l("ul",null,[l("li",null,"加粗字体代表了 JVM 虚拟机组件"),l("li",null,"对于 Oracle 的 Hotspot 虚拟机实现，不区分虚拟机栈和本地方法栈")],-1)),n[10]||(n[10]=l("p",null,[l("strong",null,"会发生内存溢出的区域")],-1)),n[11]||(n[11]=l("ul",null,[l("li",null,"不会出现内存溢出的区域 – 程序计数器"),l("li",null,[i("出现 OutOfMemoryError 的情况 "),l("ul",null,[l("li",null,"堆内存耗尽 – 对象越来越多，又一直在使用，不能被垃圾回收"),l("li",null,"方法区内存耗尽 – 加载的类越来越多，很多框架都会在运行期间动态产生新的类"),l("li",null,"虚拟机栈累积 – 每个线程最多会占用 1 M 内存，线程个数越来越多，而又长时间运行不销毁时")])]),l("li",null,[i("出现 StackOverflowError 的区域 "),l("ul",null,[l("li",null,"JVM 虚拟机栈，原因有方法递归调用未正确结束、反序列化 json 时循环引用")])])],-1)),n[12]||(n[12]=l("p",null,[l("strong",null,"方法区、永久代、元空间")],-1)),n[13]||(n[13]=l("ul",null,[l("li",null,[l("strong",null,"方法区"),i("是 JVM 规范中定义的一块内存区域，用来存储类元数据、方法字节码、即时编译器需要的信息等")]),l("li",null,[l("strong",null,"永久代"),i("是 Hotspot 虚拟机对 JVM 规范的实现（1.8 之前）")]),l("li",null,[l("strong",null,"元空间"),i("是 Hotspot 虚拟机对 JVM 规范的另一种实现（1.8 以后），使用本地内存作为这些信息的存储空间")])],-1)),n[14]||(n[14]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831170457337.png",alt:"image-20210831170457337",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[15]||(n[15]=l("p",null,"从这张图学到三点",-1)),n[16]||(n[16]=l("ul",null,[l("li",null,"当第一次用到某个类是，由类加载器将 class 文件的类元信息读入，并存储于元空间"),l("li",null,"X，Y 的类元信息是存储于元空间中，无法直接访问"),l("li",null,"可以用 X.class，Y.class 间接访问类元信息，它们俩属于 java 对象，我们的代码中可以使用")],-1)),n[17]||(n[17]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831170512418.png",alt:"image-20210831170512418",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[18]||(n[18]=l("p",null,"从这张图可以学到",-1)),n[19]||(n[19]=l("ul",null,[l("li",null,[i("堆内存中：当一个"),l("strong",null,"类加载器对象"),i("，这个类加载器对象加载的所有"),l("strong",null,"类对象"),i("，这些类对象对应的所有"),l("strong",null,"实例对象"),i("都没人引用时，GC 时就会对它们占用的对内存进行释放")]),l("li",null,[i("元空间中：内存释放"),l("strong",null,"以类加载器为单位"),i("，当堆中类加载器内存释放时，对应的元空间中的类元信息也会释放")])],-1)),n[20]||(n[20]=l("h2",{id:"_2-jvm-内存参数",tabindex:"-1"},[i("2. JVM 内存参数 "),l("a",{class:"header-anchor",href:"#_2-jvm-内存参数","aria-label":'Permalink to "2. JVM 内存参数"'},"​")],-1)),n[21]||(n[21]=l("p",null,[l("strong",null,"要求")],-1)),n[22]||(n[22]=l("ul",null,[l("li",null,"熟悉常见的 JVM 参数，尤其和大小相关的")],-1)),n[23]||(n[23]=l("p",null,[l("strong",null,"堆内存，按大小设置")],-1)),n[24]||(n[24]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831173130717.png",alt:"image-20210831173130717",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[25]||(n[25]=l("p",null,"解释：",-1)),n[26]||(n[26]=l("ul",null,[l("li",null,"-Xms 最小堆内存（包括新生代和老年代）"),l("li",null,"-Xmx 最大对内存（包括新生代和老年代）"),l("li",null,"通常建议将 -Xms 与 -Xmx 设置为大小相等，即不需要保留内存，不需要从小到大增长，这样性能较好"),l("li",null,"-XX:NewSize 与 -XX:MaxNewSize 设置新生代的最小与最大值，但一般不建议设置，由 JVM 自己控制"),l("li",null,"-Xmn 设置新生代大小，相当于同时设置了 -XX:NewSize 与 -XX:MaxNewSize 并且取值相等"),l("li",null,"保留是指，一开始不会占用那么多内存，随着使用内存越来越多，会逐步使用这部分保留内存。下同")],-1)),n[27]||(n[27]=l("p",null,[l("strong",null,"堆内存，按比例设置")],-1)),n[28]||(n[28]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831173045700.png",alt:"image-20210831173045700",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[29]||(n[29]=l("p",null,"解释：",-1)),n[30]||(n[30]=l("ul",null,[l("li",null,"-XX:NewRatio=2:1 表示老年代占两份，新生代占一份"),l("li",null,"-XX:SurvivorRatio=4:1 表示新生代分成六份，伊甸园占四份，from 和 to 各占一份")],-1)),n[31]||(n[31]=l("p",null,[l("strong",null,"元空间内存设置")],-1)),n[32]||(n[32]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831173118634.png",alt:"image-20210831173118634",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[33]||(n[33]=l("p",null,"解释：",-1)),n[34]||(n[34]=l("ul",null,[l("li",null,"class space 存储类的基本信息，最大值受 -XX:CompressedClassSpaceSize 控制"),l("li",null,"non-class space 存储除类的基本信息以外的其它信息（如方法字节码、注解等）"),l("li",null,"class space 和 non-class space 总大小受 -XX:MaxMetaspaceSize 控制")],-1)),n[35]||(n[35]=l("p",null,"注意：",-1)),n[36]||(n[36]=l("ul",null,[l("li",null,"这里 -XX:CompressedClassSpaceSize 这段空间还与是否开启了指针压缩有关，这里暂不深入展开，可以简单认为指针压缩默认开启")],-1)),n[37]||(n[37]=l("p",null,[l("strong",null,"代码缓存内存设置")],-1)),n[38]||(n[38]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831173148816.png",alt:"image-20210831173148816",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[39]||(n[39]=l("p",null,"解释：",-1)),n[40]||(n[40]=l("ul",null,[l("li",null,"如果 -XX:ReservedCodeCacheSize < 240m，所有优化机器代码不加区分存在一起"),l("li",null,[i("否则，分成三个区域（图中笔误 mthod 拼写错误，少一个 e） "),l("ul",null,[l("li",null,"non-nmethods - JVM 自己用的代码"),l("li",null,"profiled nmethods - 部分优化的机器码"),l("li",null,"non-profiled nmethods - 完全优化的机器码")])])],-1)),n[41]||(n[41]=l("p",null,[l("strong",null,"线程内存设置")],-1)),n[42]||(n[42]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831173155481.png",alt:"image-20210831173155481",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[43]||(n[43]=l("blockquote",null,[l("p",null,[l("em",null,[l("strong",null,"官方参考文档")])]),l("ul",null,[l("li",null,[l("a",{href:"https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE",target:"_blank",rel:"noreferrer"},"https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE")])])],-1)),n[44]||(n[44]=l("h2",{id:"_3-jvm-垃圾回收",tabindex:"-1"},[i("3. JVM 垃圾回收 "),l("a",{class:"header-anchor",href:"#_3-jvm-垃圾回收","aria-label":'Permalink to "3. JVM 垃圾回收"'},"​")],-1)),n[45]||(n[45]=l("p",null,[l("strong",null,"要求")],-1)),n[46]||(n[46]=l("ul",null,[l("li",null,"掌握垃圾回收算法"),l("li",null,"掌握分代回收思想"),l("li",null,"理解三色标记及漏标处理"),l("li",null,"了解常见垃圾回收器")],-1)),n[47]||(n[47]=l("p",null,[l("strong",null,"三种垃圾回收算法")],-1)),n[48]||(n[48]=l("p",null,"标记清除法",-1)),n[49]||(n[49]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831211008162.png",alt:"image-20210831211008162",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[50]||(n[50]=l("p",null,"解释：",-1)),n[51]||(n[51]=l("ol",null,[l("li",null,"找到 GC Root 对象，即那些一定不会被回收的对象，如正执行方法内局部变量引用的对象、静态变量引用的对象"),l("li",null,"标记阶段：沿着 GC Root 对象的引用链找，直接或间接引用到的对象加上标记"),l("li",null,"清除阶段：释放未加标记的对象占用的内存")],-1)),n[52]||(n[52]=l("p",null,"要点：",-1)),n[53]||(n[53]=l("ul",null,[l("li",null,"标记速度与存活对象线性关系"),l("li",null,"清除速度与内存大小线性关系"),l("li",null,"缺点是会产生内存碎片")],-1)),n[54]||(n[54]=l("p",null,"标记整理法",-1)),n[55]||(n[55]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831211641241.png",alt:"image-20210831211641241",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[56]||(n[56]=l("p",null,"解释：",-1)),n[57]||(n[57]=l("ol",null,[l("li",null,"前面的标记阶段、清理阶段与标记清除法类似"),l("li",null,"多了一步整理的动作，将存活对象向一端移动，可以避免内存碎片产生")],-1)),n[58]||(n[58]=l("p",null,"特点：",-1)),n[59]||(n[59]=l("ul",null,[l("li",null,[l("p",null,"标记速度与存活对象线性关系")]),l("li",null,[l("p",null,"清除与整理速度与内存大小成线性关系")]),l("li",null,[l("p",null,"缺点是性能上较慢")])],-1)),n[60]||(n[60]=l("p",null,"标记复制法",-1)),n[61]||(n[61]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831212125813.png",alt:"image-20210831212125813",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[62]||(n[62]=l("p",null,"解释：",-1)),n[63]||(n[63]=l("ol",null,[l("li",null,"将整个内存分成两个大小相等的区域，from 和 to，其中 to 总是处于空闲，from 存储新创建的对象"),l("li",null,"标记阶段与前面的算法类似"),l("li",null,"在找出存活对象后，会将它们从 from 复制到 to 区域，复制的过程中自然完成了碎片整理"),l("li",null,"复制完成后，交换 from 和 to 的位置即可")],-1)),n[64]||(n[64]=l("p",null,"特点：",-1)),n[65]||(n[65]=l("ul",null,[l("li",null,"标记与复制速度与存活对象成线性关系"),l("li",null,"缺点是会占用成倍的空间")],-1)),n[66]||(n[66]=l("p",null,[l("strong",null,"GC 与分代回收算法")],-1)),n[67]||(n[67]=l("p",null,"GC 的目的在于实现无用对象内存自动释放，减少内存碎片、加快分配速度",-1)),n[68]||(n[68]=l("p",null,"GC 要点：",-1)),n[69]||(n[69]=l("ul",null,[l("li",null,[i("回收区域是"),l("strong",null,"堆内存"),i("，不包括虚拟机栈")]),l("li",null,[i("判断无用对象，使用"),l("strong",null,"可达性分析算法"),i("，"),l("strong",null,"三色标记法"),i("标记存活对象，回收未标记对象")]),l("li",null,[i("GC 具体的实现称为"),l("strong",null,"垃圾回收器")]),l("li",null,[i("GC 大都采用了"),l("strong",null,"分代回收思想"),l("ul",null,[l("li",null,"理论依据是大部分对象朝生夕灭，用完立刻就可以回收，另有少部分对象会长时间存活，每次很难回收"),l("li",null,[i("根据这两类对象的特性将回收区域分为"),l("strong",null,"新生代"),i("和"),l("strong",null,"老年代"),i("，新生代采用标记复制法、老年代一般采用标记整理法")])])]),l("li",null,[i("根据 GC 的规模可以分成 "),l("strong",null,"Minor GC"),i("，"),l("strong",null,"Mixed GC"),i("，"),l("strong",null,"Full GC")])],-1)),n[70]||(n[70]=l("p",null,[l("strong",null,"分代回收")],-1)),n[71]||(n[71]=l("ol",null,[l("li",null,"伊甸园 eden，最初对象都分配到这里，与幸存区 survivor（分成 from 和 to）合称新生代，")],-1)),n[72]||(n[72]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831213622704.png",alt:"image-20210831213622704",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[73]||(n[73]=l("ol",{start:"2"},[l("li",null,"当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象")],-1)),n[74]||(n[74]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831213640110.png",alt:"image-20210831213640110",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[75]||(n[75]=l("ol",{start:"3"},[l("li",null,"将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放")],-1)),n[76]||(n[76]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831213657861.png",alt:"image-20210831213657861",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[77]||(n[77]=l("ol",{start:"4"},[l("li",null,"将 from 和 to 交换位置")],-1)),n[78]||(n[78]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831213708776.png",alt:"image-20210831213708776",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[79]||(n[79]=l("ol",{start:"5"},[l("li",null,"经过一段时间后伊甸园的内存又出现不足")],-1)),n[80]||(n[80]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831213724858.png",alt:"image-20210831213724858",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[81]||(n[81]=l("ol",{start:"6"},[l("li",null,"标记伊甸园与 from（现阶段没有）的存活对象")],-1)),n[82]||(n[82]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831213737669.png",alt:"image-20210831213737669",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[83]||(n[83]=l("ol",{start:"7"},[l("li",null,"将存活对象采用复制算法复制到 to 中")],-1)),n[84]||(n[84]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831213804315.png",alt:"image-20210831213804315",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[85]||(n[85]=l("ol",{start:"8"},[l("li",null,"复制完毕后，伊甸园和 from 内存都得到释放")],-1)),n[86]||(n[86]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831213815371.png",alt:"image-20210831213815371",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[87]||(n[87]=l("ol",{start:"9"},[l("li",null,"将 from 和 to 交换位置")],-1)),n[88]||(n[88]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831213826017.png",alt:"image-20210831213826017",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[89]||(n[89]=l("ol",{start:"10"},[l("li",null,"老年代 old，当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）")],-1)),n[90]||(n[90]=l("p",null,[l("strong",null,"GC 规模")],-1)),n[91]||(n[91]=l("ul",null,[l("li",null,[l("p",null,"Minor GC 发生在新生代的垃圾回收，暂停时间短")]),l("li",null,[l("p",null,"Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有")]),l("li",null,[l("p",null,[i("Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，"),l("strong",null,"应尽力避免")])])],-1)),n[92]||(n[92]=l("p",null,[l("strong",null,"三色标记")],-1)),n[93]||(n[93]=l("p",null,"即用三种颜色记录对象的标记状态",-1)),n[94]||(n[94]=l("ul",null,[l("li",null,"黑色 – 已标记"),l("li",null,"灰色 – 标记中"),l("li",null,"白色 – 还未标记")],-1)),n[95]||(n[95]=l("ol",null,[l("li",null,"起始的三个对象还未处理完成，用灰色表示")],-1)),n[96]||(n[96]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831215016566.png",alt:"image-20210831215016566",style:{zoom:"50%"}},null,-1)),n[97]||(n[97]=l("ol",{start:"2"},[l("li",null,"该对象的引用已经处理完成，用黑色表示，黑色引用的对象变为灰色")],-1)),n[98]||(n[98]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831215033510.png",alt:"image-20210831215033510",style:{zoom:"50%"}},null,-1)),n[99]||(n[99]=l("ol",{start:"3"},[l("li",null,"依次类推")],-1)),n[100]||(n[100]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831215105280.png",alt:"image-20210831215105280",style:{zoom:"50%"}},null,-1)),n[101]||(n[101]=l("ol",{start:"4"},[l("li",null,"沿着引用链都标记了一遍")],-1)),n[102]||(n[102]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831215146276.png",alt:"image-20210831215146276",style:{zoom:"50%"}},null,-1)),n[103]||(n[103]=l("ol",{start:"5"},[l("li",null,"最后为标记的白色对象，即为垃圾")],-1)),n[104]||(n[104]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831215158311.png",alt:"image-20210831215158311",style:{zoom:"50%"}},null,-1)),n[105]||(n[105]=l("p",null,[l("strong",null,"并发漏标问题")],-1)),n[106]||(n[106]=l("p",null,[i("比较先进的垃圾回收器都支持"),l("strong",null,"并发标记"),i("，即在标记过程中，用户线程仍然能工作。但这样带来一个新的问题，如果用户线程修改了对象引用，那么就存在漏标问题。例如：")],-1)),n[107]||(n[107]=l("ol",null,[l("li",null,"如图所示标记工作尚未完成")],-1)),n[108]||(n[108]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831215846876.png",alt:"image-20210831215846876",style:{zoom:"50%"}},null,-1)),n[109]||(n[109]=l("ol",{start:"2"},[l("li",null,"用户线程同时在工作，断开了第一层 3、4 两个对象之间的引用，这时对于正在处理 3 号对象的垃圾回收线程来讲，它会将 4 号对象当做是白色垃圾")],-1)),n[110]||(n[110]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831215904073.png",alt:"image-20210831215904073",style:{zoom:"50%"}},null,-1)),n[111]||(n[111]=l("ol",{start:"3"},[l("li",null,"但如果其他用户线程又建立了 2、4 两个对象的引用，这时因为 2 号对象是黑色已处理对象了，因此垃圾回收线程不会察觉到这个引用关系的变化，从而产生了漏标")],-1)),n[112]||(n[112]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831215919493.png",alt:"image-20210831215919493",style:{zoom:"50%"}},null,-1)),n[113]||(n[113]=l("ol",{start:"4"},[l("li",null,"如果用户线程让黑色对象引用了一个新增对象，一样会存在漏标问题")],-1)),n[114]||(n[114]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831220004062.png",alt:"image-20210831220004062",style:{zoom:"50%"}},null,-1)),n[115]||(n[115]=l("p",null,[i("因此对于"),l("strong",null,"并发标记"),i("而言，必须解决漏标问题，也就是要记录标记过程中的变化。有两种解决方法：")],-1)),n[116]||(n[116]=l("ol",null,[l("li",null,[i("Incremental Update 增量更新法，CMS 垃圾回收器采用 "),l("ul",null,[l("li",null,"思路是拦截每次赋值动作，只要赋值发生，被赋值的对象就会被记录下来，在重新标记阶段再确认一遍")])]),l("li",null,[i("Snapshot At The Beginning，SATB 原始快照法，G1 垃圾回收器采用 "),l("ul",null,[l("li",null,"思路也是拦截每次赋值动作，不过记录的对象不同，也需要在重新标记阶段对这些对象二次处理"),l("li",null,"新加对象会被记录"),l("li",null,"被删除引用关系的对象也被记录")])])],-1)),n[117]||(n[117]=l("p",null,[l("strong",null,"垃圾回收器 - Parallel GC")],-1)),n[118]||(n[118]=l("ul",null,[l("li",null,[l("p",null,"eden 内存不足发生 Minor GC，采用标记复制算法，需要暂停用户线程")]),l("li",null,[l("p",null,"old 内存不足发生 Full GC，采用标记整理算法，需要暂停用户线程")]),l("li",null,[l("p",null,[l("strong",null,"注重吞吐量")])])],-1)),n[119]||(n[119]=l("p",null,[l("strong",null,"垃圾回收器 - ConcurrentMarkSweep GC")],-1)),n[120]||(n[120]=l("ul",null,[l("li",null,[l("p",null,[i("它是工作在 old 老年代，支持"),l("strong",null,"并发标记"),i("的一款回收器，采用"),l("strong",null,"并发清除"),i("算法")]),l("ul",null,[l("li",null,"并发标记时不需暂停用户线程"),l("li",null,"重新标记时仍需暂停用户线程")])]),l("li",null,[l("p",null,"如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC")]),l("li",null,[l("p",null,[l("strong",null,"注重响应时间")])])],-1)),n[121]||(n[121]=l("p",null,[l("strong",null,"垃圾回收器 - G1 GC")],-1)),n[122]||(n[122]=l("ul",null,[l("li",null,[l("strong",null,"响应时间与吞吐量兼顾")]),l("li",null,"划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备"),l("li",null,"分成三个阶段：新生代回收、并发标记、混合收集"),l("li",null,"如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC")],-1)),n[123]||(n[123]=l("p",null,[l("strong",null,"G1 回收阶段 - 新生代回收")],-1)),n[124]||(n[124]=l("ol",null,[l("li",null,"初始时，所有区域都处于空闲状态")],-1)),n[125]||(n[125]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831222639754.png",alt:"image-20210831222639754",style:{zoom:"50%"}},null,-1)),n[126]||(n[126]=l("ol",{start:"2"},[l("li",null,"创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象")],-1)),n[127]||(n[127]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831222653802.png",alt:"image-20210831222653802",style:{zoom:"50%"}},null,-1)),n[128]||(n[128]=l("ol",{start:"3"},[l("li",null,"当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程")],-1)),n[129]||(n[129]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831222705814.png",alt:"image-20210831222705814",style:{zoom:"50%"}},null,-1)),n[130]||(n[130]=l("ol",{start:"4"},[l("li",null,"复制完成，将之前的伊甸园内存释放")],-1)),n[131]||(n[131]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831222724999.png",alt:"image-20210831222724999",style:{zoom:"50%"}},null,-1)),n[132]||(n[132]=l("ol",{start:"5"},[l("li",null,"随着时间流逝，伊甸园的内存又有不足")],-1)),n[133]||(n[133]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831222737928.png",alt:"image-20210831222737928",style:{zoom:"50%"}},null,-1)),n[134]||(n[134]=l("ol",{start:"6"},[l("li",null,"将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代")],-1)),n[135]||(n[135]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831222752787.png",alt:"image-20210831222752787",style:{zoom:"50%"}},null,-1)),n[136]||(n[136]=l("ol",{start:"7"},[l("li",null,"释放伊甸园以及之前幸存区的内存")],-1)),n[137]||(n[137]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831222803281.png",alt:"image-20210831222803281",style:{zoom:"50%"}},null,-1)),n[138]||(n[138]=l("p",null,[l("strong",null,"G1 回收阶段 - 并发标记与混合收集")],-1)),n[139]||(n[139]=l("ol",null,[l("li",null,"当老年代占用内存超过阈值后，触发并发标记，这时无需暂停用户线程")],-1)),n[140]||(n[140]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831222813959.png",alt:"image-20210831222813959",style:{zoom:"50%"}},null,-1)),n[141]||(n[141]=l("ol",{start:"2"},[l("li",null,[i("并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据"),l("strong",null,"暂停时间目标"),i("优先回收价值高（存活对象少）的区域（这也是 Gabage First 名称的由来）。")])],-1)),n[142]||(n[142]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831222828104.png",alt:"image-20210831222828104",style:{zoom:"50%"}},null,-1)),n[143]||(n[143]=l("ol",{start:"3"},[l("li",null,"混合收集阶段中，参与复制的有 eden、survivor、old，下图显示了伊甸园和幸存区的存活对象复制")],-1)),n[144]||(n[144]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831222841096.png",alt:"image-20210831222841096",style:{zoom:"50%"}},null,-1)),n[145]||(n[145]=l("ol",{start:"4"},[l("li",null,"下图显示了老年代和幸存区晋升的存活对象的复制")],-1)),n[146]||(n[146]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831222859760.png",alt:"image-20210831222859760",style:{zoom:"50%"}},null,-1)),n[147]||(n[147]=l("ol",{start:"5"},[l("li",null,"复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集")],-1)),n[148]||(n[148]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210831222919182.png",alt:"image-20210831222919182",style:{zoom:"50%"}},null,-1)),n[149]||(n[149]=l("h2",{id:"_4-内存溢出",tabindex:"-1"},[i("4. 内存溢出 "),l("a",{class:"header-anchor",href:"#_4-内存溢出","aria-label":'Permalink to "4. 内存溢出"'},"​")],-1)),n[150]||(n[150]=l("p",null,[l("strong",null,"要求")],-1)),n[151]||(n[151]=l("ul",null,[l("li",null,"能够说出几种典型的导致内存溢出的情况")],-1)),n[152]||(n[152]=l("p",null,[l("strong",null,"典型情况")],-1)),n[153]||(n[153]=l("ul",null,[l("li",null,[i("误用线程池导致的内存溢出 "),l("ul",null,[l("li",null,"参考 day03.TestOomThreadPool")])]),l("li",null,[i("查询数据量太大导致的内存溢出 "),l("ul",null,[l("li",null,"参考 day03.TestOomTooManyObject")])]),l("li",null,[i("动态生成类导致的内存溢出 "),l("ul",null,[l("li",null,"参考 day03.TestOomTooManyClass")])])],-1)),n[154]||(n[154]=l("h2",{id:"_5-类加载",tabindex:"-1"},[i("5. 类加载 "),l("a",{class:"header-anchor",href:"#_5-类加载","aria-label":'Permalink to "5. 类加载"'},"​")],-1)),n[155]||(n[155]=l("p",null,[l("strong",null,"要求")],-1)),n[156]||(n[156]=l("ul",null,[l("li",null,"掌握类加载阶段"),l("li",null,"掌握类加载器"),l("li",null,"理解双亲委派机制")],-1)),n[157]||(n[157]=l("p",null,[l("strong",null,"类加载过程的三个阶段")],-1)),n[158]||(n[158]=l("ol",null,[l("li",null,[l("p",null,"加载"),l("ol",null,[l("li",null,[l("p",null,"将类的字节码载入方法区，并创建类.class 对象")]),l("li",null,[l("p",null,"如果此类的父类没有加载，先加载父类")]),l("li",null,[l("p",null,"加载是懒惰执行")])])]),l("li",null,[l("p",null,"链接"),l("ol",null,[l("li",null,"验证 – 验证类是否符合 Class 规范，合法性、安全性检查"),l("li",null,"准备 – 为 static 变量分配空间，设置默认值"),l("li",null,"解析 – 将常量池的符号引用解析为直接引用")])]),l("li",null,[l("p",null,"初始化"),l("ol",null,[l("li",null,[i("静态代码块、static 修饰的变量赋值、static final 修饰的引用类型变量赋值，会被合并成一个 "),l("code",null,"<cinit>"),i(" 方法，在初始化时被调用")]),l("li",null,"static final 修饰的基本类型变量赋值，在链接阶段就已完成"),l("li",null,"初始化是懒惰执行")])])],-1)),n[159]||(n[159]=l("blockquote",null,[l("p",null,[l("em",null,[l("strong",null,"验证手段")])]),l("ul",null,[l("li",null,"使用 jps 查看进程号"),l("li",null,[i("使用 jhsdb 调试，执行命令 "),l("code",null,"jhsdb.exe hsdb"),i(" 打开它的图形界面 "),l("ul",null,[l("li",null,"Class Browser 可以查看当前 jvm 中加载了哪些类"),l("li",null,"控制台的 universe 命令查看堆内存范围"),l("li",null,"控制台的 g1regiondetails 命令查看 region 详情"),l("li",null,[l("code",null,"scanoops 起始地址 结束地址 对象类型"),i(" 可以根据类型查找某个区间内的对象地址")]),l("li",null,[i("控制台的 "),l("code",null,"inspect 地址"),i(" 指令能够查看这个地址对应的对象详情")])])]),l("li",null,"使用 javap 命令可以查看 class 字节码")])],-1)),n[160]||(n[160]=l("blockquote",null,[l("p",null,[l("em",null,[l("strong",null,"代码说明")])]),l("ul",null,[l("li",null,"day03.loader.TestLazy - 验证类的加载是懒惰的，用到时才触发类加载"),l("li",null,"day03.loader.TestFinal - 验证使用 final 修饰的变量不会触发类加载")])],-1)),n[161]||(n[161]=l("p",null,[l("strong",null,"jdk 8 的类加载器")],-1)),n[162]||(n[162]=l("table",null,[l("thead",null,[l("tr",null,[l("th",null,[l("strong",null,"名称")]),l("th",null,[l("strong",null,"加载哪的类")]),l("th",null,[l("strong",null,"说明")])])]),l("tbody",null,[l("tr",null,[l("td",null,"Bootstrap ClassLoader"),l("td",null,"JAVA_HOME/jre/lib"),l("td",null,"无法直接访问")]),l("tr",null,[l("td",null,"Extension ClassLoader"),l("td",null,"JAVA_HOME/jre/lib/ext"),l("td",null,"上级为 Bootstrap，显示为 null")]),l("tr",null,[l("td",null,"Application ClassLoader"),l("td",null,"classpath"),l("td",null,"上级为 Extension")]),l("tr",null,[l("td",null,"自定义类加载器"),l("td",null,"自定义"),l("td",null,"上级为 Application")])])],-1)),n[163]||(n[163]=l("p",null,[l("strong",null,"双亲委派机制")],-1)),n[164]||(n[164]=l("p",null,"所谓的双亲委派，就是指优先委派上级类加载器进行加载，如果上级类加载器",-1)),n[165]||(n[165]=l("ul",null,[l("li",null,"能找到这个类，由上级加载，加载后该类也对下级加载器可见"),l("li",null,"找不到这个类，则下级类加载器才有资格执行加载")],-1)),n[166]||(n[166]=l("p",null,"双亲委派的目的有两点",-1)),n[167]||(n[167]=l("ol",null,[l("li",null,[l("p",null,"让上级类加载器中的类对下级共享（反之不行），即能让你的类能依赖到 jdk 提供的核心类")]),l("li",null,[l("p",null,"让类的加载有优先次序，保证核心类优先加载")])],-1)),n[168]||(n[168]=l("p",null,[l("strong",null,"对双亲委派的误解")],-1)),n[169]||(n[169]=l("p",null,"下面面试题的回答是错误的",-1)),n[170]||(n[170]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210901110910016.png",alt:"image-20210901110910016",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[171]||(n[171]=l("p",null,"错在哪了？",-1)),n[172]||(n[172]=l("ul",null,[l("li",null,[l("p",null,"自己编写类加载器就能加载一个假冒的 java.lang.System 吗? 答案是不行。")]),l("li",null,[l("p",null,"假设你自己的类加载器用双亲委派，那么优先由启动类加载器加载真正的 java.lang.System，自然不会加载假冒的")]),l("li",null,[l("p",null,"假设你自己的类加载器不用双亲委派，那么你的类加载器加载假冒的 java.lang.System 时，它需要先加载父类 java.lang.Object，而你没有用委派，找不到 java.lang.Object 所以加载会失败")]),l("li",null,[l("p",null,[l("strong",null,"以上也仅仅是假设"),i("。事实上操作你就会发现，自定义类加载器加载以 java. 打头的类时，会抛安全异常，在 jdk9 以上版本这些特殊包名都与模块进行了绑定，更连编译都过不了")])])],-1)),n[173]||(n[173]=l("blockquote",null,[l("p",null,[l("em",null,[l("strong",null,"代码说明")])]),l("ul",null,[l("li",null,"day03.loader.TestJdk9ClassLoader - 演示类加载器与模块的绑定关系")])],-1)),n[174]||(n[174]=l("h2",{id:"_6-四种引用",tabindex:"-1"},[i("6. 四种引用 "),l("a",{class:"header-anchor",href:"#_6-四种引用","aria-label":'Permalink to "6. 四种引用"'},"​")],-1)),n[175]||(n[175]=l("p",null,[l("strong",null,"要求")],-1)),n[176]||(n[176]=l("ul",null,[l("li",null,"掌握四种引用")],-1)),n[177]||(n[177]=l("p",null,[l("strong",null,"强引用")],-1)),n[178]||(n[178]=l("ol",null,[l("li",null,[l("p",null,"普通变量赋值即为强引用，如 A a = new A();")]),l("li",null,[l("p",null,"通过 GC Root 的引用链，如果强引用不到该对象，该对象才能被回收")])],-1)),n[179]||(n[179]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210901111903574.png",alt:"image-20210901111903574",style:{zoom:"80%"}},null,-1)),n[180]||(n[180]=l("p",null,[l("strong",null,"软引用（SoftReference）")],-1)),n[181]||(n[181]=l("ol",null,[l("li",null,[l("p",null,"例如：SoftReference a = new SoftReference(new A());")]),l("li",null,[l("p",null,"如果仅有软引用该对象时，首次垃圾回收不会回收该对象，如果内存仍不足，再次回收时才会释放对象")]),l("li",null,[l("p",null,"软引用自身需要配合引用队列来释放")]),l("li",null,[l("p",null,"典型例子是反射数据")])],-1)),n[182]||(n[182]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210901111957328.png",alt:"image-20210901111957328",style:{zoom:"80%"}},null,-1)),n[183]||(n[183]=l("p",null,[l("strong",null,"弱引用（WeakReference）")],-1)),n[184]||(n[184]=l("ol",null,[l("li",null,[l("p",null,"例如：WeakReference a = new WeakReference(new A());")]),l("li",null,[l("p",null,"如果仅有弱引用引用该对象时，只要发生垃圾回收，就会释放该对象")]),l("li",null,[l("p",null,"弱引用自身需要配合引用队列来释放")]),l("li",null,[l("p",null,"典型例子是 ThreadLocalMap 中的 Entry 对象")])],-1)),n[185]||(n[185]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210901112107707.png",alt:"image-20210901112107707",style:{zoom:"80%"}},null,-1)),n[186]||(n[186]=l("p",null,[l("strong",null,"虚引用（PhantomReference）")],-1)),n[187]||(n[187]=l("ol",null,[l("li",null,[l("p",null,"例如： PhantomReference a = new PhantomReference(new A(), referenceQueue);")]),l("li",null,[l("p",null,"必须配合引用队列一起使用，当虚引用所引用的对象被回收时，由 Reference Handler 线程将虚引用对象入队，这样就可以知道哪些对象被回收，从而对它们关联的资源做进一步处理")]),l("li",null,[l("p",null,"典型例子是 Cleaner 释放 DirectByteBuffer 关联的直接内存")])],-1)),n[188]||(n[188]=l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210901112157901.png",alt:"image-20210901112157901",style:{zoom:"80%"}},null,-1)),n[189]||(n[189]=l("blockquote",null,[l("p",null,[l("em",null,[l("strong",null,"代码说明")])]),l("ul",null,[l("li",null,"day03.reference.TestPhantomReference - 演示虚引用的基本用法"),l("li",null,"day03.reference.TestWeakReference - 模拟 ThreadLocalMap, 采用引用队列释放 entry 内存")])],-1)),n[190]||(n[190]=l("h2",{id:"_7-finalize",tabindex:"-1"},[i("7. finalize "),l("a",{class:"header-anchor",href:"#_7-finalize","aria-label":'Permalink to "7. finalize"'},"​")],-1)),n[191]||(n[191]=l("p",null,[l("strong",null,"要求")],-1)),n[192]||(n[192]=l("ul",null,[l("li",null,"掌握 finalize 的工作原理与缺点")],-1)),n[193]||(n[193]=l("p",null,[l("strong",null,"finalize")],-1)),n[194]||(n[194]=l("ul",null,[l("li",null,"它是 Object 中的一个方法，如果子类重写它，垃圾回收时此方法会被调用，可以在其中进行资源释放和清理工作"),l("li",null,"将资源释放和清理放在 finalize 方法中非常不好，非常影响性能，严重时甚至会引起 OOM，从 Java9 开始就被标注为 @Deprecated，不建议被使用了")],-1)),n[195]||(n[195]=l("p",null,[l("strong",null,"finalize 原理")],-1)),n[196]||(n[196]=l("ol",null,[l("li",null,"对 finalize 方法进行处理的核心逻辑位于 java.lang.ref.Finalizer 类中，它包含了名为 unfinalized 的静态变量（双向链表结构），Finalizer 也可被视为另一种引用对象（地位与软、弱、虚相当，只是不对外，无法直接使用）"),l("li",null,"当重写了 finalize 方法的对象，在构造方法调用之时，JVM 都会将其包装成一个 Finalizer 对象，并加入 unfinalized 链表中")],-1)),n[197]||(n[197]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210901121032813.png",alt:"image-20210901121032813",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[198]||(n[198]=l("ol",{start:"3"},[l("li",null,"Finalizer 类中还有另一个重要的静态变量，即 ReferenceQueue 引用队列，刚开始它是空的。当狗对象可以被当作垃圾回收时，就会把这些狗对象对应的 Finalizer 对象加入此引用队列"),l("li",null,"但此时 Dog 对象还没法被立刻回收，因为 unfinalized -> Finalizer 这一引用链还在引用它嘛，为的是【先别着急回收啊，等我调完 finalize 方法，再回收】"),l("li",null,"FinalizerThread 线程会从 ReferenceQueue 中逐一取出每个 Finalizer 对象，把它们从链表断开并真正调用 finallize 方法")],-1)),n[199]||(n[199]=l("figure",null,[l("img",{src:"https://gcore.jsdelivr.net/gh/imLKlauS/blog-picture@main/blogs/image-20210901122228916.png",alt:"image-20210901122228916",loading:"lazy",decoding:"async",class:"lazy"})],-1)),n[200]||(n[200]=l("ol",{start:"6"},[l("li",null,"由于整个 Finalizer 对象已经从 unfinalized 链表中断开，这样没谁能引用到它和狗对象，所以下次 gc 时就被回收了")],-1)),n[201]||(n[201]=l("p",null,[l("strong",null,"finalize 缺点")],-1)),n[202]||(n[202]=l("ul",null,[l("li",null,"无法保证资源释放：FinalizerThread 是守护线程，代码很有可能没来得及执行完，线程就结束了"),l("li",null,"无法判断是否发生错误：执行 finalize 方法时，会吞掉任意异常（Throwable）"),l("li",null,"内存释放不及时：重写了 finalize 方法的对象在第一次被 gc 时，并不能及时释放它占用的内存，因为要等着 FinalizerThread 调用完 finalize，把它从 unfinalized 队列移除后，第二次 gc 时才能真正释放内存"),l("li",null,"有的文章提到【Finalizer 线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的CPU时间较少，因此它永远也赶不上主线程的步伐】这个显然是错误的，FinalizerThread 的优先级较普通线程更高，原因应该是 finalize 串行执行慢等原因综合导致")],-1)),n[203]||(n[203]=l("blockquote",null,[l("p",null,[l("em",null,[l("strong",null,"代码说明")])]),l("ul",null,[l("li",null,"day03.reference.TestFinalize - finalize 的测试代码")])],-1))]),"main-header":u(()=>[o(t.$slots,"main-header")]),"main-header-after":u(()=>[o(t.$slots,"main-header-after")]),"main-nav":u(()=>[o(t.$slots,"main-nav")]),"main-content-before":u(()=>[o(t.$slots,"main-content-before")]),"main-content":u(()=>[o(t.$slots,"main-content")]),"main-content-after":u(()=>[o(t.$slots,"main-content-after")]),"main-nav-before":u(()=>[o(t.$slots,"main-nav-before")]),"main-nav-after":u(()=>[o(t.$slots,"main-nav-after")]),comment:u(()=>[o(t.$slots,"comment")]),footer:u(()=>[o(t.$slots,"footer")]),aside:u(()=>[o(t.$slots,"aside")]),"aside-custom":u(()=>[o(t.$slots,"aside-custom")]),default:u(()=>[o(t.$slots,"default")]),_:3},8,["frontmatter"])}}};export{A as default,M as usePageData};
